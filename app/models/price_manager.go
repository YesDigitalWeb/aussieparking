package models

import (
	"fmt"
	"math"
	"strings"
	"time"

	"github.com/corestoreio/csfw/storage/money"
	"github.com/jinzhu/gorm"
	"github.com/jinzhu/now"
	"github.com/theplant/qor-enterprise/promotion"

	"github.com/theplant/aussie/config"
	"github.com/theplant/aussie/db"
)

type PriceManager struct {
	*Order
	tx *gorm.DB
}

func NewPriceManager(order *Order, tx *gorm.DB) *PriceManager {
	return &PriceManager{Order: order, tx: tx}
}

func (pm *PriceManager) Process() (err error) {
	ranges, err := FindRanges(pm.From, pm.To)
	if err != nil {
		return
	}

	var (
		order     = pm.Order
		items     []*OrderItem
		startFrom = now.New(order.From).BeginningOfDay()
		duration  = int(math.Ceil(order.To.Sub(startFrom).Hours() / 24))
		oldAmount = order.Amount
		cleaning  string
	)

	for i := 0; i < duration; i++ {
		var isSpecial bool
		var currentDay = startFrom.Add(time.Hour * 24 * time.Duration(i))
		r := getRangeByDate(ranges, currentDay)

		if i == duration-1 {
			if order.To.Format("15:06") > r.SpecialTimeSince {
				isSpecial = true
			}

			if order.CleanProductId > 0 {
				item := pm.generateOrderItem(order.CleanProductId, currentDay, isSpecial, r)
				items = append(items, item)
				if order.Cleaning == "" {
					cleaning = CleanStatePending
				}
			}
		} else if i == 0 {
			if order.From.Format("15:06") > r.SpecialTimeSince {
				isSpecial = true
			}
		}

		item := pm.generateOrderItem(order.ParkingProductName, currentDay, isSpecial, r)
		items = append(items, item)
	}

	order.Cleaning = cleaning

	if err = pm.updateOrderItemsAndOrderAmount(items); err != nil {
		return
	}

	if changeAmount := sub(order.Amount, oldAmount); changeAmount != 0 {
		// Generate Note if amount changed
		var notes = []string{}
		notes = append(notes, fmt.Sprintf("%-10v %10v %40v", "Date", "Rate", "Description"))
		for _, item := range items {
			product := retrieveProductsByIdOrName(item.ProductId)
			notes = append(notes, fmt.Sprintf("%10v %10v %40v", item.Day, fmt.Sprintf("$%v", item.Amount()), product.Name))
		}
		note := Note{
			Note:                  strings.Join(notes, "\n"),
			ChangedAmount:         changeAmount,
			OriginalChangedAmount: changeAmount,
			OrderId:               order.Id,
			State:                 order.GetState(),
			AutoGenerated:         true,
		}
		err = pm.tx.Save(&note).Error
	}

	return
}

// updateOrderItemsAndOrderAmount save changes in database.
// Calculate Order.Amount here to make sure order is using old OrderItem.Amount.
func (pm *PriceManager) updateOrderItemsAndOrderAmount(items []*OrderItem) (err error) {
	var ids []uint64
	var originalItemsMap map[string]OrderItem
	if pm.Order.IsNonDraft() {
		if originalItemsMap, err = pm.getOriginalItemsMap(); err != nil {
			return
		}
	}

	order := pm.Order
	order.Amount = 0
	for _, item := range items {
		if pm.Order.IsNonDraft() {
			// check if should keep old items unchanged
			if oldItem, ok := originalItemsMap[pm.orderItemKey(*item)]; ok {
				order.Amount = add(order.Amount, oldItem.Price)

				ids = append(ids, oldItem.Id)
				continue
			}
		}

		order.Amount = add(order.Amount, item.Price)

		query := &OrderItem{Type: item.Type, Day: item.Day, OrderId: pm.Order.Id}
		changes := map[string]interface{}{
			"ProductId":    item.ProductId,
			"Price":        item.Price,
			"SpecialPrice": item.SpecialPrice,
			"Discount":     item.Discount,
		}
		if err = pm.tx.Where(query).Assign(changes).FirstOrCreate(item).Error; err != nil {
			return
		}
		ids = append(ids, item.Id)
	}

	order.Amount = add(order.Amount, order.DiscountValue) // Important. Note amount changes included
	if err = pm.tx.Model(order).UpdateColumn(Order{
		Amount:   order.Amount,
		Cleaning: order.Cleaning,
		// assigned in function matchDiscount. see comments in
		// generateOrderItem bellow.
		DiscountId: order.DiscountId,
	}).Error; err != nil {
		return
	}

	if len(ids) == 0 {
		return
	}

	return pm.tx.Delete(&OrderItem{}, "id NOT IN (?) AND order_id = ?", ids, pm.Order.Id).Error
}

func (pm *PriceManager) getOriginalItemsMap() (map[string]OrderItem, error) {
	originalItemsMap := map[string]OrderItem{}
	var originalItems []OrderItem
	if err := pm.tx.Where("order_id = ?", pm.Order.Id).Find(&originalItems).Error; err != nil {
		return nil, err
	}
	for _, item := range originalItems {
		originalItemsMap[pm.orderItemKey(item)] = item
	}
	return originalItemsMap, nil
}

func (pm *PriceManager) orderItemKey(item OrderItem) string {
	return fmt.Sprintf("%d-%s-%s", pm.Order.Id, item.Day, item.Type)
}

func (pm *PriceManager) generateOrderItem(productIdOrName interface{}, currentDay time.Time, isSpecial bool, r Range) *OrderItem {
	product := retrieveProductsByIdOrName(productIdOrName)
	item := OrderItem{
		OrderId:   pm.Order.Id,
		ProductId: product.Id,
		Day:       currentDay.Format("2006-01-02"),
		Type:      product.Type,
	}

	var rp RangeProduct
	for _, rp = range r.RangeProducts {
		if rp.ProductId == product.Id {
			item.Price = rp.Price
			if isSpecial {
				item.Price = add(item.Price, rp.SpecialPrice)
				item.SpecialPrice = rp.SpecialPrice
			}
			break
		}
	}

	// Applies discount and assigns order.DiscountId
	// Discount handlers is registered in discount.go:init()
	item.Order = pm.Order
	if err := promotion.Compute(db.DB, &item); err != nil {
		config.ReportError(err)
	}
	item.Price = sub(item.Price, item.Discount)

	return &item
}

func retrieveProductsByIdOrName(idOrName interface{}) Product {
	for _, ps := range [][]*Product{AllParkingProducts, AllCleanProducts} {
		for _, p := range ps {
			switch x := idOrName.(type) {
			case string:
				if x == p.Name {
					return *p
				}
			case uint64:
				if x == p.Id {
					return *p
				}
			}
		}
	}
	return Product{}
}

func init() {
	money.DefaultPrecision(100)
}

func mul(f1, f2 float64) float64 {
	return money.New().Setf(f1).Mulf(f2).Getf()
}

func div(f1, f2 float64) float64 {
	return money.New().Setf(f1).Div(money.New().Setf(f2)).Getf()
}

func add(f1, f2 float64) float64 {
	return money.New().Setf(f1).Add(money.New().Setf(f2)).Getf()
}

func sub(f1, f2 float64) float64 {
	return money.New().Setf(f1).Sub(money.New().Setf(f2)).Getf()
}
